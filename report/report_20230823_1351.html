<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Test Report</title>
    <link href="assets/style.css" rel="stylesheet" type="text/css"/></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) { // eslint-disable-line no-redeclare
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function findAll(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sortColumn(elem) {
    toggleSortStates(elem);
    const colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    let key;
    if (elem.classList.contains('result')) {
        key = keyResult;
    } else if (elem.classList.contains('links')) {
        key = keyLink;
    } else {
        key = keyAlpha;
    }
    sortTable(elem, key(colIndex));
}

function showAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(showExtras);
}

function hideAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(hideExtras);
}

function showExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.remove('collapsed');
    expandcollapse.classList.remove('expander');
    expandcollapse.classList.add('collapser');
}

function hideExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.add('collapsed');
    expandcollapse.classList.remove('collapser');
    expandcollapse.classList.add('expander');
}

function showFilters() {
    const filterItems = document.getElementsByClassName('filter');
    for (let i = 0; i < filterItems.length; i++)
        filterItems[i].hidden = false;
}

function addCollapse() {
    // Add links for show/hide all
    const resulttable = find('table#results-table');
    const showhideall = document.createElement('p');
    showhideall.innerHTML = '<a href="javascript:showAllExtras()">Show all details</a> / ' +
                            '<a href="javascript:hideAllExtras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    findAll('.col-result').forEach(function(elem) {
        const collapsed = getQueryParameter('collapsed') || 'Passed';
        const extras = elem.parentNode.nextElementSibling;
        const expandcollapse = document.createElement('span');
        if (extras.classList.contains('collapsed')) {
            expandcollapse.classList.add('expander');
        } else if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add('collapsed');
            expandcollapse.classList.add('expander');
        } else {
            expandcollapse.classList.add('collapser');
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener('click', function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains('collapsed')) {
                showExtras(event.currentTarget);
            } else {
                hideExtras(event.currentTarget);
            }
        });
    });
}

function getQueryParameter(name) {
    const match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () { // eslint-disable-line no-unused-vars
    resetSortHeaders();

    addCollapse();

    showFilters();

    sortColumn(find('.initial-sort'));

    findAll('.sortable').forEach(function(elem) {
        elem.addEventListener('click',
            function() {
                sortColumn(elem);
            }, false);
    });
}

function sortTable(clicked, keyFunc) {
    const rows = findAll('.results-table-row');
    const reversed = !clicked.classList.contains('asc');
    const sortedRows = sort(rows, keyFunc, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    const thead = document.getElementById('results-table-head');
    document.getElementById('results-table').remove();
    const parent = document.createElement('table');
    parent.id = 'results-table';
    parent.appendChild(thead);
    sortedRows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName('BODY')[0].appendChild(parent);
}

function sort(items, keyFunc, reversed) {
    const sortArray = items.map(function(item, i) {
        return [keyFunc(item), i];
    });

    sortArray.sort(function(a, b) {
        const keyA = a[0];
        const keyB = b[0];

        if (keyA == keyB) return 0;

        if (reversed) {
            return keyA < keyB ? 1 : -1;
        } else {
            return keyA > keyB ? 1 : -1;
        }
    });

    return sortArray.map(function(item) {
        const index = item[1];
        return items[index];
    });
}

function keyAlpha(colIndex) {
    return function(elem) {
        return elem.childNodes[1].childNodes[colIndex].firstChild.data.toLowerCase();
    };
}

function keyLink(colIndex) {
    return function(elem) {
        const dataCell = elem.childNodes[1].childNodes[colIndex].firstChild;
        return dataCell == null ? '' : dataCell.innerText.toLowerCase();
    };
}

function keyResult(colIndex) {
    return function(elem) {
        const strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
            'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[colIndex].firstChild.data);
    };
}

function resetSortHeaders() {
    findAll('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    findAll('.sortable').forEach(function(elem) {
        const icon = document.createElement('div');
        icon.className = 'sort-icon';
        icon.textContent = 'vvv';
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove('desc', 'active');
        elem.classList.add('asc', 'inactive');
    });
}

function toggleSortStates(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        resetSortHeaders();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function isAllRowsHidden(value) {
    return value.hidden == false;
}

function filterTable(elem) { // eslint-disable-line no-unused-vars
    const outcomeAtt = 'data-test-result';
    const outcome = elem.getAttribute(outcomeAtt);
    const classOutcome = outcome + ' results-table-row';
    const outcomeRows = document.getElementsByClassName(classOutcome);

    for(let i = 0; i < outcomeRows.length; i++){
        outcomeRows[i].hidden = !elem.checked;
    }

    const rows = findAll('.results-table-row').filter(isAllRowsHidden);
    const allRowsHidden = rows.length == 0 ? true : false;
    const notFoundMessage = document.getElementById('not-found-message');
    notFoundMessage.hidden = !allRowsHidden;
}
</script>
    <h1>report_20230823_1351.html</h1>
    <p>Report generated on 23-Aug-2023 at 13:51:56 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v3.1.1</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>Packages</td>
        <td>{"pluggy": "1.0.0", "py": "1.11.0", "pytest": "7.1.2"}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Windows-10-10.0.19041-SP0</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{"html": "3.1.1", "metadata": "2.0.2", "ssh": "0.1"}</td></tr>
      <tr>
        <td>Python</td>
        <td>3.9.0</td></tr></table>
    <h2>Summary</h2>
    <p>1 tests ran in 6.73 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="passed">0 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="failed">1 failed</span>, <input checked="true" class="filter" data-test-result="error" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="error">0 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable" col="duration">Duration</th>
          <th class="sortable links" col="links">Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">pytest_basic.py::TestClass::test_04_AAA_RADIUS</td>
          <td class="col-duration">6.15</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x000001D4F9DF3E80&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x000001D4F9DE7FA0&gt;, hostname = &#x27;0.0.0.0&#x27;, port = 22, username = &#x27;root&#x27;<br/>password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False, look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=604, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 50248)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15, auth_timeout = None<br/>gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x000001D4F9DE5CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   OSError: [WinError 10049] 요청한 주소는 해당 컨텍스트에서 유효하지 않습니다</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: OSError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;pytest_basic.TestClass object at 0x000001D4F9DF3F70&gt;<br/><br/>    def test_04_AAA_RADIUS(self):<br/>        testName =  sys._getframe(0).f_code.co_name<br/>        Title = &quot;#&quot; * 5 + &quot; AAA with RADIUS Test &quot; + &quot;#&quot; * 5<br/>        print(Title)<br/>        try:<br/>&gt;           bc.disTitle(self.dut1,Title)<br/><br/>pytest_basic.py:115: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>host = &#x27;0.0.0.0&#x27;, Title = &#x27;##### AAA with RADIUS Test #####&#x27;<br/><br/>    def disTitle(host,Title):<br/>&gt;       with connect(host) as child:<br/><br/>basic\basicConf.py:64: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>host = &#x27;0.0.0.0&#x27;<br/><br/>    def connect(host):<br/>        login ={<br/>            &#x27;device_type&#x27;:&#x27;cisco_ios&#x27;,<br/>            &#x27;ip&#x27;: host,<br/>            &#x27;username&#x27;:&#x27;root&#x27;,<br/>            &#x27;password&#x27;:&#x27;admin&#x27;,<br/>            &#x27;session_timeout&#x27;: 120,<br/>            &#x27;timeout&#x27;: 120,<br/>            &#x27;global_delay_factor&#x27;: 2,<br/>            }<br/>&gt;       device = ConnectHandler(**login)<br/><br/>basic\basicConf.py:30: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>args = (), kwargs = {&#x27;device_type&#x27;: &#x27;cisco_ios&#x27;, &#x27;global_delay_factor&#x27;: 2, &#x27;ip&#x27;: &#x27;0.0.0.0&#x27;, &#x27;password&#x27;: &#x27;admin&#x27;, ...}<br/>device_type = &#x27;cisco_ios&#x27;, ConnectionClass = &lt;class &#x27;netmiko.cisco.cisco_ios.CiscoIosSSH&#x27;&gt;<br/><br/>    def ConnectHandler(*args, **kwargs):<br/>        &quot;&quot;&quot;Factory function selects the proper class and creates object based on device_type.&quot;&quot;&quot;<br/>        device_type = kwargs[&quot;device_type&quot;]<br/>        if device_type not in platforms:<br/>            if device_type is None:<br/>                msg_str = platforms_str<br/>            else:<br/>                msg_str = telnet_platforms_str if &quot;telnet&quot; in device_type else platforms_str<br/>            raise ValueError(<br/>                &quot;Unsupported &#x27;device_type&#x27; &quot;<br/>                &quot;currently supported platforms are: {}&quot;.format(msg_str)<br/>            )<br/>        ConnectionClass = ssh_dispatcher(device_type)<br/>&gt;       return ConnectionClass(*args, **kwargs)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x000001D4F9DF3E80&gt;, args = ()<br/>kwargs = {&#x27;_legacy_mode&#x27;: False, &#x27;device_type&#x27;: &#x27;cisco_ios&#x27;, &#x27;fast_cli&#x27;: True, &#x27;global_delay_factor&#x27;: 2, ...}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        # Cisco-IOS defaults to fast_cli=True and legacy_mode=False<br/>        kwargs.setdefault(&quot;fast_cli&quot;, True)<br/>        kwargs.setdefault(&quot;_legacy_mode&quot;, False)<br/>&gt;       return super().__init__(*args, **kwargs)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x000001D4F9DF3E80&gt;, ip = &#x27;0.0.0.0&#x27;, host = &#x27;&#x27;, username = &#x27;root&#x27;<br/>password = &#x27;admin&#x27;, secret = &#x27;&#x27;, port = 22, device_type = &#x27;cisco_ios&#x27;, verbose = False, global_delay_factor = 2<br/>global_cmd_verify = None, use_keys = False, key_file = None, pkey = None, passphrase = None, allow_agent = False<br/>ssh_strict = False, system_host_keys = False, alt_host_keys = False, alt_key_file = &#x27;&#x27;, ssh_config_file = None, conn_timeout = 5<br/>auth_timeout = None, banner_timeout = 15, blocking_timeout = 20, timeout = 120, session_timeout = 120, keepalive = 0<br/>default_enter = None, response_return = None, serial_settings = {}, fast_cli = True, _legacy_mode = False, session_log = None<br/>session_log_record_writes = False, session_log_file_mode = &#x27;write&#x27;, allow_auto_change = False, encoding = &#x27;ascii&#x27;, sock = None<br/>auto_connect = True<br/><br/>    def __init__(<br/>        self,<br/>        ip=&quot;&quot;,<br/>        host=&quot;&quot;,<br/>        username=&quot;&quot;,<br/>        password=None,<br/>        secret=&quot;&quot;,<br/>        port=None,<br/>        device_type=&quot;&quot;,<br/>        verbose=False,<br/>        global_delay_factor=1,<br/>        global_cmd_verify=None,<br/>        use_keys=False,<br/>        key_file=None,<br/>        pkey=None,<br/>        passphrase=None,<br/>        allow_agent=False,<br/>        ssh_strict=False,<br/>        system_host_keys=False,<br/>        alt_host_keys=False,<br/>        alt_key_file=&quot;&quot;,<br/>        ssh_config_file=None,<br/>        #<br/>        # Connect timeouts<br/>        # ssh-connect --&gt; TCP conn (conn_timeout) --&gt; SSH-banner (banner_timeout)<br/>        #       --&gt; Auth response (auth_timeout)<br/>        conn_timeout=5,<br/>        auth_timeout=None,  # Timeout to wait for authentication response<br/>        banner_timeout=15,  # Timeout to wait for the banner to be presented (post TCP-connect)<br/>        # Other timeouts<br/>        blocking_timeout=20,  # Read blocking timeout<br/>        timeout=100,  # TCP connect timeout | overloaded to read-loop timeout<br/>        session_timeout=60,  # Used for locking/sharing the connection<br/>        keepalive=0,<br/>        default_enter=None,<br/>        response_return=None,<br/>        serial_settings=None,<br/>        fast_cli=False,<br/>        _legacy_mode=True,<br/>        session_log=None,<br/>        session_log_record_writes=False,<br/>        session_log_file_mode=&quot;write&quot;,<br/>        allow_auto_change=False,<br/>        encoding=&quot;ascii&quot;,<br/>        sock=None,<br/>        auto_connect=True,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Initialize attributes for establishing connection to target device.<br/>    <br/>        :param ip: IP address of target device. Not required if `host` is<br/>            provided.<br/>        :type ip: str<br/>    <br/>        :param host: Hostname of target device. Not required if `ip` is<br/>                provided.<br/>        :type host: str<br/>    <br/>        :param username: Username to authenticate against target device if<br/>                required.<br/>        :type username: str<br/>    <br/>        :param password: Password to authenticate against target device if<br/>                required.<br/>        :type password: str<br/>    <br/>        :param secret: The enable password if target device requires one.<br/>        :type secret: str<br/>    <br/>        :param port: The destination port used to connect to the target<br/>                device.<br/>        :type port: int or None<br/>    <br/>        :param device_type: Class selection based on device type.<br/>        :type device_type: str<br/>    <br/>        :param verbose: Enable additional messages to standard output.<br/>        :type verbose: bool<br/>    <br/>        :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).<br/>        :type global_delay_factor: int<br/>    <br/>        :param use_keys: Connect to target device using SSH keys.<br/>        :type use_keys: bool<br/>    <br/>        :param key_file: Filename path of the SSH key file to use.<br/>        :type key_file: str<br/>    <br/>        :param pkey: SSH key object to use.<br/>        :type pkey: paramiko.PKey<br/>    <br/>        :param passphrase: Passphrase to use for encrypted key; password will be used for key<br/>                decryption if not specified.<br/>        :type passphrase: str<br/>    <br/>        :param allow_agent: Enable use of SSH key-agent.<br/>        :type allow_agent: bool<br/>    <br/>        :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which<br/>                means unknown SSH host keys will be accepted).<br/>        :type ssh_strict: bool<br/>    <br/>        :param system_host_keys: Load host keys from the users known_hosts file.<br/>        :type system_host_keys: bool<br/>        :param alt_host_keys: If `True` host keys will be loaded from the file specified in<br/>                alt_key_file.<br/>        :type alt_host_keys: bool<br/>    <br/>        :param alt_key_file: SSH host key file to use (if alt_host_keys=True).<br/>        :type alt_key_file: str<br/>    <br/>        :param ssh_config_file: File name of OpenSSH configuration file.<br/>        :type ssh_config_file: str<br/>    <br/>        :param timeout: Connection timeout.<br/>        :type timeout: float<br/>    <br/>        :param session_timeout: Set a timeout for parallel requests.<br/>        :type session_timeout: float<br/>    <br/>        :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.<br/>        :type auth_timeout: float<br/>    <br/>        :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).<br/>        :type banner_timeout: float<br/>    <br/>        :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.<br/>                Currently defaults to 0, for backwards compatibility (it will not attempt<br/>                to keep the connection alive).<br/>        :type keepalive: int<br/>    <br/>        :param default_enter: Character(s) to send to correspond to enter key (default: \n).<br/>        :type default_enter: str<br/>    <br/>        :param response_return: Character(s) to use in normalized return data to represent<br/>                enter key (default: \n)<br/>        :type response_return: str<br/>    <br/>        :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor<br/>                to select smallest of global and specific. Sets default global_delay_factor to .1<br/>                (default: False)<br/>        :type fast_cli: boolean<br/>    <br/>        :param session_log: File path or BufferedIOBase subclass object to write the session log to.<br/>        :type session_log: str<br/>    <br/>        :param session_log_record_writes: The session log generally only records channel reads due<br/>                to eliminate command duplication due to command echo. You can enable this if you<br/>                want to record both channel reads and channel writes in the log (default: False).<br/>        :type session_log_record_writes: boolean<br/>    <br/>        :param session_log_file_mode: &quot;write&quot; or &quot;append&quot; for session_log file mode<br/>                (default: &quot;write&quot;)<br/>        :type session_log_file_mode: str<br/>    <br/>        :param allow_auto_change: Allow automatic configuration changes for terminal settings.<br/>                (default: False)<br/>        :type allow_auto_change: bool<br/>    <br/>        :param encoding: Encoding to be used when writing bytes to the output channel.<br/>                (default: ascii)<br/>        :type encoding: str<br/>    <br/>        :param sock: An open socket or socket-like object (such as a `.Channel`) to use for<br/>                communication to the target host (default: None).<br/>        :type sock: socket<br/>    <br/>        :param global_cmd_verify: Control whether command echo verification is enabled or disabled<br/>                (default: None). Global attribute takes precedence over function `cmd_verify`<br/>                argument. Value of `None` indicates to use function `cmd_verify` argument.<br/>        :type global_cmd_verify: bool|None<br/>    <br/>        :param auto_connect: Control whether Netmiko automatically establishes the connection as<br/>                part of the object creation (default: True).<br/>        :type auto_connect: bool<br/>        &quot;&quot;&quot;<br/>        self.remote_conn = None<br/>    <br/>        self.TELNET_RETURN = &quot;\r\n&quot;<br/>        if default_enter is None:<br/>            if &quot;telnet&quot; not in device_type:<br/>                self.RETURN = &quot;\n&quot;<br/>            else:<br/>                self.RETURN = self.TELNET_RETURN<br/>        else:<br/>            self.RETURN = default_enter<br/>    <br/>        # Line Separator in response lines<br/>        self.RESPONSE_RETURN = &quot;\n&quot; if response_return is None else response_return<br/>        if ip:<br/>            self.host = ip.strip()<br/>        elif host:<br/>            self.host = host.strip()<br/>        if not ip and not host and &quot;serial&quot; not in device_type:<br/>            raise ValueError(&quot;Either ip or host must be set&quot;)<br/>        if port is None:<br/>            if &quot;telnet&quot; in device_type:<br/>                port = 23<br/>            else:<br/>                port = 22<br/>        self.port = int(port)<br/>    <br/>        self.username = username<br/>        self.password = password<br/>        self.secret = secret<br/>        self.device_type = device_type<br/>        self.ansi_escape_codes = False<br/>        self.verbose = verbose<br/>        self.auth_timeout = auth_timeout<br/>        self.banner_timeout = banner_timeout<br/>        self.blocking_timeout = blocking_timeout<br/>        self.conn_timeout = conn_timeout<br/>        self.session_timeout = session_timeout<br/>        self.timeout = timeout<br/>        self.keepalive = keepalive<br/>        self.allow_auto_change = allow_auto_change<br/>        self.encoding = encoding<br/>        self.sock = sock<br/>    <br/>        # Netmiko will close the session_log if we open the file<br/>        self.session_log = None<br/>        self.session_log_record_writes = session_log_record_writes<br/>        self._session_log_close = False<br/>        # Ensures last write operations prior to disconnect are recorded.<br/>        self._session_log_fin = False<br/>        if session_log is not None:<br/>            if isinstance(session_log, str):<br/>                # If session_log is a string, open a file corresponding to string name.<br/>                self.open_session_log(filename=session_log, mode=session_log_file_mode)<br/>            elif isinstance(session_log, io.BufferedIOBase):<br/>                # In-memory buffer or an already open file handle<br/>                self.session_log = session_log<br/>            else:<br/>                raise ValueError(<br/>                    &quot;session_log must be a path to a file, a file handle, &quot;<br/>                    &quot;or a BufferedIOBase subclass.&quot;<br/>                )<br/>    <br/>        # Default values<br/>        self.serial_settings = {<br/>            &quot;port&quot;: &quot;COM1&quot;,<br/>            &quot;baudrate&quot;: 9600,<br/>            &quot;bytesize&quot;: serial.EIGHTBITS,<br/>            &quot;parity&quot;: serial.PARITY_NONE,<br/>            &quot;stopbits&quot;: serial.STOPBITS_ONE,<br/>        }<br/>        if serial_settings is None:<br/>            serial_settings = {}<br/>        self.serial_settings.update(serial_settings)<br/>    <br/>        if &quot;serial&quot; in device_type:<br/>            self.host = &quot;serial&quot;<br/>            comm_port = self.serial_settings.pop(&quot;port&quot;)<br/>            # Get the proper comm port reference if a name was enterred<br/>            comm_port = check_serial_port(comm_port)<br/>            self.serial_settings.update({&quot;port&quot;: comm_port})<br/>    <br/>        self.fast_cli = fast_cli<br/>        self._legacy_mode = _legacy_mode<br/>        self.global_delay_factor = global_delay_factor<br/>        self.global_cmd_verify = global_cmd_verify<br/>        if self.fast_cli and self.global_delay_factor == 1:<br/>            self.global_delay_factor = 0.1<br/>    <br/>        # set in set_base_prompt method<br/>        self.base_prompt = &quot;&quot;<br/>        self._session_locker = Lock()<br/>    <br/>        # determine if telnet or SSH<br/>        if &quot;_telnet&quot; in device_type:<br/>            self.protocol = &quot;telnet&quot;<br/>            self.password = password or &quot;&quot;<br/>        elif &quot;_serial&quot; in device_type:<br/>            self.protocol = &quot;serial&quot;<br/>            self.password = password or &quot;&quot;<br/>        else:<br/>            self.protocol = &quot;ssh&quot;<br/>    <br/>            if not ssh_strict:<br/>                self.key_policy = paramiko.AutoAddPolicy()<br/>            else:<br/>                self.key_policy = paramiko.RejectPolicy()<br/>    <br/>            # Options for SSH host_keys<br/>            self.use_keys = use_keys<br/>            self.key_file = (<br/>                path.abspath(path.expanduser(key_file)) if key_file else None<br/>            )<br/>            self.pkey = pkey<br/>            self.passphrase = passphrase<br/>            self.allow_agent = allow_agent<br/>            self.system_host_keys = system_host_keys<br/>            self.alt_host_keys = alt_host_keys<br/>            self.alt_key_file = alt_key_file<br/>    <br/>            # For SSH proxy support<br/>            self.ssh_config_file = ssh_config_file<br/>    <br/>        # Establish the remote connection<br/>        if auto_connect:<br/>&gt;           self._open()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x000001D4F9DF3E80&gt;<br/><br/>    def _open(self):<br/>        &quot;&quot;&quot;Decouple connection creation from __init__ for mocking.&quot;&quot;&quot;<br/>        self._modify_connection_params()<br/>&gt;       self.establish_connection()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x000001D4F9DF3E80&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 0.0.0.0:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x000001D4F9DE7DC0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x000001D4F9DE7D60&gt;, hostname = &#x27;0.0.0.0&#x27;, port = 22, username = &#x27;root&#x27;<br/>password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False, look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=1068, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 50249)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15, auth_timeout = None<br/>gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x000001D4F9E25EE0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   OSError: [WinError 10049] 요청한 주소는 해당 컨텍스트에서 유효하지 않습니다</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: OSError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;pytest_basic.TestClass object at 0x000001D4F9DF3F70&gt;<br/><br/>    def test_04_AAA_RADIUS(self):<br/>        testName =  sys._getframe(0).f_code.co_name<br/>        Title = &quot;#&quot; * 5 + &quot; AAA with RADIUS Test &quot; + &quot;#&quot; * 5<br/>        print(Title)<br/>        try:<br/>            bc.disTitle(self.dut1,Title)<br/>            # radius.configAaaRadius(self.dut1)<br/>            # guiradius.startRadiusServer()<br/>            time.sleep(5)<br/>            assert radius.checklogin(self.dut1) == 2<br/>            time.sleep(2)<br/>            guiradius.stopRadiusServer()<br/>            time.sleep(5)<br/>            assert radius.checklogin(self.dut1) == 2<br/>            time.sleep(2)<br/>            radius.removeAaaRadius(self.dut1)<br/>            time.sleep(2)<br/>        except:<br/>            guiradius.stopRadiusServer()<br/>            time.sleep(2)<br/>&gt;           radius.removeAaaRadius(self.dut1)<br/><br/>pytest_basic.py:130: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>radius\radiusConf.py:25: in removeAaaRadius<br/>    with bc.connect(host) as child:<br/>basic\basicConf.py:30: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x000001D4F9DE7DC0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 0.0.0.0:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/> ------------------------------Captured stdout call------------------------------ <br/>##### AAA with RADIUS Test #####
<br/> -----------------------------Captured log teardown------------------------------ <br/>ERROR    root:pytest_basic.py:52 teardown_class<br/></div></td></tr></tbody></table></body></html>