<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Test Report</title>
    <link href="assets/style.css" rel="stylesheet" type="text/css"/></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) { // eslint-disable-line no-redeclare
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function findAll(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sortColumn(elem) {
    toggleSortStates(elem);
    const colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    let key;
    if (elem.classList.contains('result')) {
        key = keyResult;
    } else if (elem.classList.contains('links')) {
        key = keyLink;
    } else {
        key = keyAlpha;
    }
    sortTable(elem, key(colIndex));
}

function showAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(showExtras);
}

function hideAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(hideExtras);
}

function showExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.remove('collapsed');
    expandcollapse.classList.remove('expander');
    expandcollapse.classList.add('collapser');
}

function hideExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.add('collapsed');
    expandcollapse.classList.remove('collapser');
    expandcollapse.classList.add('expander');
}

function showFilters() {
    const filterItems = document.getElementsByClassName('filter');
    for (let i = 0; i < filterItems.length; i++)
        filterItems[i].hidden = false;
}

function addCollapse() {
    // Add links for show/hide all
    const resulttable = find('table#results-table');
    const showhideall = document.createElement('p');
    showhideall.innerHTML = '<a href="javascript:showAllExtras()">Show all details</a> / ' +
                            '<a href="javascript:hideAllExtras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    findAll('.col-result').forEach(function(elem) {
        const collapsed = getQueryParameter('collapsed') || 'Passed';
        const extras = elem.parentNode.nextElementSibling;
        const expandcollapse = document.createElement('span');
        if (extras.classList.contains('collapsed')) {
            expandcollapse.classList.add('expander');
        } else if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add('collapsed');
            expandcollapse.classList.add('expander');
        } else {
            expandcollapse.classList.add('collapser');
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener('click', function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains('collapsed')) {
                showExtras(event.currentTarget);
            } else {
                hideExtras(event.currentTarget);
            }
        });
    });
}

function getQueryParameter(name) {
    const match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () { // eslint-disable-line no-unused-vars
    resetSortHeaders();

    addCollapse();

    showFilters();

    sortColumn(find('.initial-sort'));

    findAll('.sortable').forEach(function(elem) {
        elem.addEventListener('click',
            function() {
                sortColumn(elem);
            }, false);
    });
}

function sortTable(clicked, keyFunc) {
    const rows = findAll('.results-table-row');
    const reversed = !clicked.classList.contains('asc');
    const sortedRows = sort(rows, keyFunc, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    const thead = document.getElementById('results-table-head');
    document.getElementById('results-table').remove();
    const parent = document.createElement('table');
    parent.id = 'results-table';
    parent.appendChild(thead);
    sortedRows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName('BODY')[0].appendChild(parent);
}

function sort(items, keyFunc, reversed) {
    const sortArray = items.map(function(item, i) {
        return [keyFunc(item), i];
    });

    sortArray.sort(function(a, b) {
        const keyA = a[0];
        const keyB = b[0];

        if (keyA == keyB) return 0;

        if (reversed) {
            return keyA < keyB ? 1 : -1;
        } else {
            return keyA > keyB ? 1 : -1;
        }
    });

    return sortArray.map(function(item) {
        const index = item[1];
        return items[index];
    });
}

function keyAlpha(colIndex) {
    return function(elem) {
        return elem.childNodes[1].childNodes[colIndex].firstChild.data.toLowerCase();
    };
}

function keyLink(colIndex) {
    return function(elem) {
        const dataCell = elem.childNodes[1].childNodes[colIndex].firstChild;
        return dataCell == null ? '' : dataCell.innerText.toLowerCase();
    };
}

function keyResult(colIndex) {
    return function(elem) {
        const strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
            'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[colIndex].firstChild.data);
    };
}

function resetSortHeaders() {
    findAll('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    findAll('.sortable').forEach(function(elem) {
        const icon = document.createElement('div');
        icon.className = 'sort-icon';
        icon.textContent = 'vvv';
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove('desc', 'active');
        elem.classList.add('asc', 'inactive');
    });
}

function toggleSortStates(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        resetSortHeaders();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function isAllRowsHidden(value) {
    return value.hidden == false;
}

function filterTable(elem) { // eslint-disable-line no-unused-vars
    const outcomeAtt = 'data-test-result';
    const outcome = elem.getAttribute(outcomeAtt);
    const classOutcome = outcome + ' results-table-row';
    const outcomeRows = document.getElementsByClassName(classOutcome);

    for(let i = 0; i < outcomeRows.length; i++){
        outcomeRows[i].hidden = !elem.checked;
    }

    const rows = findAll('.results-table-row').filter(isAllRowsHidden);
    const allRowsHidden = rows.length == 0 ? true : false;
    const notFoundMessage = document.getElementById('not-found-message');
    notFoundMessage.hidden = !allRowsHidden;
}
</script>
    <h1>report_20230526_0934.html</h1>
    <p>Report generated on 26-May-2023 at 09:34:50 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v3.1.1</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>Packages</td>
        <td>{"pluggy": "1.0.0", "py": "1.11.0", "pytest": "7.1.2"}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Windows-10-10.0.19041-SP0</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{"html": "3.1.1", "metadata": "2.0.2", "ssh": "0.1"}</td></tr>
      <tr>
        <td>Python</td>
        <td>3.9.0</td></tr></table>
    <h2>Summary</h2>
    <p>0 tests ran in 6.41 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="passed">0 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="failed">0 failed</span>, <input checked="true" class="filter" data-test-result="error" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="error">12 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable" col="duration">Duration</th>
          <th class="sortable links" col="links">Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_001_max_vty::setup</td>
          <td class="col-duration">5.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_002_conf_vty::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_003_max_vlan::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_004_max_svc::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_005_static_lag::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_006_basic_lacp::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_007_basic_lldp::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_008_basic_eoam::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_099_plog::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_101_basic_flexport::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_102_flexport_example::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">pytest_m6424.py::Test_m6424::test_103_flexport_breakout::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>    def establish_connection(self, width=511, height=1000):<br/>        &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>        Timeout will generate a NetmikoTimeoutException<br/>        Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>        :param width: Specified width of the VT100 terminal window (default: 511)<br/>        :type width: int<br/>    <br/>        :param height: Specified height of the VT100 terminal window (default: 1000)<br/>        :type height: int<br/>        &quot;&quot;&quot;<br/>        if self.protocol == &quot;telnet&quot;:<br/>            self.remote_conn = telnetlib.Telnet(<br/>                self.host, port=self.port, timeout=self.timeout<br/>            )<br/>            self.telnet_login()<br/>        elif self.protocol == &quot;serial&quot;:<br/>            self.remote_conn = serial.Serial(**self.serial_settings)<br/>            self.serial_login()<br/>        elif self.protocol == &quot;ssh&quot;:<br/>            ssh_connect_params = self._connect_params_dict()<br/>            self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>            # initiate SSH connection<br/>            try:<br/>&gt;               self.remote_conn_pre.connect(**ssh_connect_params)<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:920: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;paramiko.client.SSHClient object at 0x00000191607DF2B0&gt;, hostname = &#x27;192.168.0.201&#x27;, port = 22<br/>username = &#x27;root&#x27;, password = &#x27;admin&#x27;, pkey = None, key_filename = None, timeout = 5, allow_agent = False<br/>look_for_keys = False, compress = False<br/>sock = &lt;socket.socket fd=700, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;0.0.0.0&#x27;, 57591), raddr=(&#x27;192.168.0.201&#x27;, 22)&gt;<br/>gss_auth = False, gss_kex = False, gss_deleg_creds = True, gss_host = None, banner_timeout = 15<br/>auth_timeout = None, gss_trust_dns = True, passphrase = None, disabled_algorithms = None<br/><br/>    def connect(<br/>        self,<br/>        hostname,<br/>        port=SSH_PORT,<br/>        username=None,<br/>        password=None,<br/>        pkey=None,<br/>        key_filename=None,<br/>        timeout=None,<br/>        allow_agent=True,<br/>        look_for_keys=True,<br/>        compress=False,<br/>        sock=None,<br/>        gss_auth=False,<br/>        gss_kex=False,<br/>        gss_deleg_creds=True,<br/>        gss_host=None,<br/>        banner_timeout=None,<br/>        auth_timeout=None,<br/>        gss_trust_dns=True,<br/>        passphrase=None,<br/>        disabled_algorithms=None,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Connect to an SSH server and authenticate to it.  The server&#x27;s host key<br/>        is checked against the system host keys (see `load_system_host_keys`)<br/>        and any local host keys (`load_host_keys`).  If the server&#x27;s hostname<br/>        is not found in either set of host keys, the missing host key policy<br/>        is used (see `set_missing_host_key_policy`).  The default policy is<br/>        to reject the key and raise an `.SSHException`.<br/>    <br/>        Authentication is attempted in the following order of priority:<br/>    <br/>            - The ``pkey`` or ``key_filename`` passed in (if any)<br/>    <br/>              - ``key_filename`` may contain OpenSSH public certificate paths<br/>                as well as regular private-key paths; when files ending in<br/>                ``-cert.pub`` are found, they are assumed to match a private<br/>                key, and both components will be loaded. (The private key<br/>                itself does *not* need to be listed in ``key_filename`` for<br/>                this to occur - *just* the certificate.)<br/>    <br/>            - Any key we can find through an SSH agent<br/>            - Any &quot;id_rsa&quot;, &quot;id_dsa&quot; or &quot;id_ecdsa&quot; key discoverable in<br/>              ``~/.ssh/``<br/>    <br/>              - When OpenSSH-style public certificates exist that match an<br/>                existing such private key (so e.g. one has ``id_rsa`` and<br/>                ``id_rsa-cert.pub``) the certificate will be loaded alongside<br/>                the private key and used for authentication.<br/>    <br/>            - Plain username/password auth, if a password was given<br/>    <br/>        If a private key requires a password to unlock it, and a password is<br/>        passed in, that password will be used to attempt to unlock the key.<br/>    <br/>        :param str hostname: the server to connect to<br/>        :param int port: the server port to connect to<br/>        :param str username:<br/>            the username to authenticate as (defaults to the current local<br/>            username)<br/>        :param str password:<br/>            Used for password authentication; is also used for private key<br/>            decryption if ``passphrase`` is not given.<br/>        :param str passphrase:<br/>            Used for decrypting private keys.<br/>        :param .PKey pkey: an optional private key to use for authentication<br/>        :param str key_filename:<br/>            the filename, or list of filenames, of optional private key(s)<br/>            and/or certs to try for authentication<br/>        :param float timeout:<br/>            an optional timeout (in seconds) for the TCP connect<br/>        :param bool allow_agent:<br/>            set to False to disable connecting to the SSH agent<br/>        :param bool look_for_keys:<br/>            set to False to disable searching for discoverable private key<br/>            files in ``~/.ssh/``<br/>        :param bool compress: set to True to turn on compression<br/>        :param socket sock:<br/>            an open socket or socket-like object (such as a `.Channel`) to use<br/>            for communication to the target host<br/>        :param bool gss_auth:<br/>            ``True`` if you want to use GSS-API authentication<br/>        :param bool gss_kex:<br/>            Perform GSS-API Key Exchange and user authentication<br/>        :param bool gss_deleg_creds: Delegate GSS-API client credentials or not<br/>        :param str gss_host:<br/>            The targets name in the kerberos database. default: hostname<br/>        :param bool gss_trust_dns:<br/>            Indicates whether or not the DNS is trusted to securely<br/>            canonicalize the name of the host being connected to (default<br/>            ``True``).<br/>        :param float banner_timeout: an optional timeout (in seconds) to wait<br/>            for the SSH banner to be presented.<br/>        :param float auth_timeout: an optional timeout (in seconds) to wait for<br/>            an authentication response.<br/>        :param dict disabled_algorithms:<br/>            an optional dict passed directly to `.Transport` and its keyword<br/>            argument of the same name.<br/>    <br/>        :raises:<br/>            `.BadHostKeyException` -- if the server&#x27;s host key could not be<br/>            verified<br/>        :raises: `.AuthenticationException` -- if authentication failed<br/>        :raises:<br/>            `.SSHException` -- if there was any other error connecting or<br/>            establishing an SSH session<br/>        :raises socket.error: if a socket error occurred while connecting<br/>    <br/>        .. versionchanged:: 1.15<br/>            Added the ``banner_timeout``, ``gss_auth``, ``gss_kex``,<br/>            ``gss_deleg_creds`` and ``gss_host`` arguments.<br/>        .. versionchanged:: 2.3<br/>            Added the ``gss_trust_dns`` argument.<br/>        .. versionchanged:: 2.4<br/>            Added the ``passphrase`` argument.<br/>        .. versionchanged:: 2.6<br/>            Added the ``disabled_algorithms`` argument.<br/>        &quot;&quot;&quot;<br/>        if not sock:<br/>            errors = {}<br/>            # Try multiple possible address families (e.g. IPv4 vs IPv6)<br/>            to_try = list(self._families_and_addresses(hostname, port))<br/>            for af, addr in to_try:<br/>                try:<br/>                    sock = socket.socket(af, socket.SOCK_STREAM)<br/>                    if timeout is not None:<br/>                        try:<br/>                            sock.settimeout(timeout)<br/>                        except:<br/>                            pass<br/>&gt;                   retry_on_signal(lambda: sock.connect(addr))<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>function = &lt;function SSHClient.connect.&lt;locals&gt;.&lt;lambda&gt; at 0x00000191607C9CA0&gt;<br/><br/>    def retry_on_signal(function):<br/>        &quot;&quot;&quot;Retries function until it doesn&#x27;t raise an EINTR error&quot;&quot;&quot;<br/>        while True:<br/>            try:<br/>&gt;               return function()<br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\util.py:283: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;   retry_on_signal(lambda: sock.connect(addr))<br/><span class="error">E   socket.timeout: timed out</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\paramiko\client.py:349: timeout<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>cls = &lt;class &#x27;pytest_m6424.Test_m6424&#x27;&gt;<br/><br/>    @classmethod<br/>    def setup_class(cls): # setUP_class(cls) -&gt; unittest<br/>        logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)<br/>        logging.info(sys._getframe(0).f_code.co_name)<br/>        &quot;&quot;&quot; AAA &quot;&quot;&quot;<br/>&gt;       bc.defaultSetup(dut1)<br/><br/>pytest_basic.py:32: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>basic\basicConf.py:54: in defaultSetup<br/>    with connect(host) as child:<br/>basic\basicConf.py:29: in connect<br/>    device = ConnectHandler(**login)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\ssh_dispatcher.py:312: in ConnectHandler<br/>    return ConnectionClass(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\cisco\cisco_ios.py:17: in __init__<br/>    return super().__init__(*args, **kwargs)<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:346: in __init__<br/>    self._open()<br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:351: in _open<br/>    self.establish_connection()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;netmiko.cisco.cisco_ios.CiscoIosSSH object at 0x00000191607DF1C0&gt;, width = 511, height = 1000<br/><br/>        def establish_connection(self, width=511, height=1000):<br/>            &quot;&quot;&quot;Establish SSH connection to the network device<br/>    <br/>            Timeout will generate a NetmikoTimeoutException<br/>            Authentication failure will generate a NetmikoAuthenticationException<br/>    <br/>            :param width: Specified width of the VT100 terminal window (default: 511)<br/>            :type width: int<br/>    <br/>            :param height: Specified height of the VT100 terminal window (default: 1000)<br/>            :type height: int<br/>            &quot;&quot;&quot;<br/>            if self.protocol == &quot;telnet&quot;:<br/>                self.remote_conn = telnetlib.Telnet(<br/>                    self.host, port=self.port, timeout=self.timeout<br/>                )<br/>                self.telnet_login()<br/>            elif self.protocol == &quot;serial&quot;:<br/>                self.remote_conn = serial.Serial(**self.serial_settings)<br/>                self.serial_login()<br/>            elif self.protocol == &quot;ssh&quot;:<br/>                ssh_connect_params = self._connect_params_dict()<br/>                self.remote_conn_pre = self._build_ssh_client()<br/>    <br/>                # initiate SSH connection<br/>                try:<br/>                    self.remote_conn_pre.connect(**ssh_connect_params)<br/>                except socket.error as conn_error:<br/>                    self.paramiko_cleanup()<br/>                    msg = f&quot;&quot;&quot;TCP connection to device failed.<br/>    <br/>    Common causes of this problem are:<br/>    1. Incorrect hostname or IP address.<br/>    2. Wrong TCP port.<br/>    3. Intermediate firewall blocking access.<br/>    <br/>    Device settings: {self.device_type} {self.host}:{self.port}<br/>    <br/>    &quot;&quot;&quot;<br/>    <br/>                    # Handle DNS failures separately<br/>                    if &quot;Name or service not known&quot; in str(conn_error):<br/>                        msg = (<br/>                            f&quot;DNS failure--the hostname you provided was not resolvable &quot;<br/>                            f&quot;in DNS: {self.host}:{self.port}&quot;<br/>                        )<br/>    <br/>                    msg = msg.lstrip()<br/>&gt;                   raise NetmikoTimeoutException(msg)<br/><span class="error">E                   netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Common causes of this problem are:</span><br/><span class="error">E                   1. Incorrect hostname or IP address.</span><br/><span class="error">E                   2. Wrong TCP port.</span><br/><span class="error">E                   3. Intermediate firewall blocking access.</span><br/><span class="error">E                   </span><br/><span class="error">E                   Device settings: cisco_ios 192.168.0.201:22</span><br/><br/>C:\Users\LG\AppData\Local\Programs\Python\Python39\lib\site-packages\netmiko\base_connection.py:942: NetmikoTimeoutException<br/></div></td></tr></tbody></table></body></html>